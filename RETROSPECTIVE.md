# Ретроспектива (Лабораторна робота №3 з ООП)
**StudyBoard** — канбан-дошка для планування навчання.

**Мета** - реалізувати веб-додаток з використанням декількох JS-бібліотек, керуванням станом, локальним зберіганням і візуалізацією даних.

## 1. Які конкретні задачі планували вирішувати за допомогою бібліотек?
Метою було створити сучасний веб-застосунок, який дозволяє керувати навчальними задачами. 
Бібліотеки використовувались для:
- побудови компонентної архітектури (React),
- глобального стану та моделі даних (Zustand),
- drag & drop між колонками (hello-pangea/dnd),
- побудови статистики (Chart.js),
- локалізації (i18next),
- швидкого запуску та збірки (Vite).

## 2. Чому було обрано саме ці бібліотеки, а не аналоги?
- **React** — найпопулярніший фреймворк для SPA, добре документований.
- **Zustand** — простіший і легший за Redux.
- **@hello-pangea/dnd** — стабільна бібліотека для drag & drop, активніше підтримується, ніж react-beautiful-dnd.
- **Chart.js** — швидке створення діаграм без зайвого коду.
- **i18next** — стандарт багатомовності у React-проєктах.
- **Vite** — найшвидший dev-сервер порівняно з Create React App та Webpack.

## 3. Наскільки просто було отримати, встановити та почати використовувати бібліотеки?
Усі бібліотеки встановлюються однією командою npm. 
Після першого налаштування:
- React і Vite працювали без додаткової конфігурації.
- Zustand інтегрується в один файл.
- Chart.js і i18next мають готові приклади.

Складнощів зі встановленням не виникло.

## 4. Наскільки зрозумілою була документація бібліотек?
- **React** — детальна і структурована.
- **Zustand** — коротка, але дуже доступна.
- **hello-pangea/dnd** — має приклади, які повністю покривають звичайні сценарії.
- **Chart.js** — велика документація, але добре систематизована.
- **i18next** — містить покрокові інструкції.

Документація виявилася достатньо зрозумілою для виконання лабораторної роботи.

## 5. Наскільки зрозуміло було, які методи або компоненти бібліотек потрібно використовувати?
Так:
- У React — стандартні хуки.
- У Zustand — `create()` і прості селектори.
- У drag & drop — три ключові компоненти: `DragDropContext`, `Droppable`, `Draggable`.
- У Chart.js — базові елементи та плагіни для бар- і пай-діаграм.
- У i18next — `useTranslation()` та JSON-файли перекладів.

Не виникло необхідності шукати складні або приховані API.

## 6. Чи потрібно було писати багато надлишкового коду?
Ні. Бібліотеки значно зменшили обсяг коду:
- Zustand усунув потребу у громіздкій Redux-конфігурації.
- Drag & drop працює без самостійної обробки координат миші.
- Chart.js прибрав необхідність малювати графіку вручну.
- i18next автоматизує перемикання мов у всьому застосунку.

Код залишився коротким і чистим.

## 7. Наскільки зрозумілою була поведінка функцій бібліотек?
Поведінка була передбачуваною:
- Zustand оновлює компоненти тільки при зміні стану.
- Drag & drop правильно реагує на переміщення між колонками.
- Chart.js автоматично перемальовує графіки при зміні пропсів.
- i18next одразу застосовує нову мову в усьому інтерфейсі.

Не було непередбачуваних побічних ефектів.

## 8. Наскільки зрозумілою була взаємодія бібліотек між собою та з власним кодом?
Усі бібліотеки добре інтегрувалися одна з одною:
- Zustand забезпечив централізований стан, який читають React-компоненти та Chart.js.
- Drag & drop просто викликає методи Zustand (`moveTask`).
- i18next працює незалежно, лише підміняючи текстові ресурси.
- Chart.js отримує дані зі стану, не впливаючи на UI-логіку.

Взаємодія була логічною, модульною та прозорою.

## 9. Які проблеми виникали саме через роботу бібліотек або фреймворків, і як вони були вирішені?
### Проблеми:
- **@hello-pangea/dnd** вимагає суворої структури DOM. Порушення вкладеності призводило до помилок `Droppable context not found`.
- **Chart.js** інколи не оновлював графік автоматично після зміни даних.
- **i18next** некоректно перемикав мову без обгортки провайдера.
- **Zustand** дозволяє видозмінювати стан неконтрольовано, якщо випадково змінити внутрішні об’єкти класів.

### Як вирішено:
- Дотримано строгої структури `DragDropContext → Droppable → Draggable`.
- Для Chart.js додано унікальні ключі, що змушують графік перемальовуватись.
- i18next було ініціалізовано один раз у корені проєкту (`main.jsx`).
- У Zustand стан змінюється тільки через створення нових екземплярів моделей (`new Board()`), щоб уникнути мутування.

## 10. Позитивні аспекти використання бібліотек
- Швидка розробка UI.
- Дуже чистий та компактний код.
- Просте управління станом.
- Автоматизація складних механік (drag & drop, діаграми, локалізація).
- Легка масштабованість проєкту.
- Мінімальна кількість коду, який довелось писати вручну.

## 11. Негативні аспекти
- Drag & drop вимагає жорсткої структури компонентів.
- Chart.js має обмеження кастомізації без плагінів.
- i18next додає додаткову вкладеність у дерево компонентів.
- Відсутність типізації (без TypeScript) може ускладнити розширення коду.

## 12. Що варто робити так само, а що змінити в майбутніх проєктах?
### Робити так само:
- Використовувати React + Zustand як основу архітектури.
- Використовувати hello-pangea/dnd для drag & drop.
- Будувати статистику на Chart.js.
- Структурувати код на domain / services / state / components.
- Застосовувати i18next для багатомовності.

### Що можна вдосконалити:
- Перейти на TypeScript для кращої типізації.
- Додати React Query для роботи з даними, кешування та оновлення.
- Використовувати Tailwind або Material UI для швидшого оформлення інтерфейсу.

## Використані ресурси

- **React документація** — https://react.dev  
- **Zustand документація** — https://docs.pmnd.rs/zustand  
- **@hello-pangea/dnd документація** — https://hello-pangea.github.io/dnd  
- **Chart.js документація** — https://www.chartjs.org/docs/latest/  
- **react-chartjs-2 документація** — https://react-chartjs-2.js.org  
- **i18next документація** — https://www.i18next.com  
- **react-i18next документація** — https://react.i18next.com  
- **Vite документація** — https://vitejs.dev  
- **MDN Web Docs (довідник з JavaScript та Web API)** — https://developer.mozilla.org  
- **StackOverflow** — окремі рішення щодо роботи з бібліотеками та інтеграцією компонентів.



